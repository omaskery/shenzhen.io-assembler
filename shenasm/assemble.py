from itertools import zip_longest
import typing


from .instructions import INSTRUCTIONS, VIRTUAL_INSTRUCTIONS, FAKE_OP_CONST, FAKE_OP_ALIAS
from .intermediate import build_ir_graph, warn_unused_code, output_ir_dotfile, IntermediateNode
from .parse import Instruction, Parser
from .source import LineOfSource, SourcePosition
from .errors import IssueLog
from .chips import ChipInfo
from . import log


class Symbol(object):
    """
    represents a symbol in a symbol table, such as a constant's name or register alias
    """

    def __init__(self, source_pos: SourcePosition, name: str, value: typing.Union[str, int]):
        self._source_pos = source_pos
        self._name = name
        self._value = value

    @property
    def source_pos(self):
        return self._source_pos

    @property
    def name(self):
        return self._name

    @property
    def value(self):
        return self._value


def assemble(issues: IssueLog, lines: [LineOfSource], chip: ChipInfo) -> ([Instruction], [IntermediateNode]):
    """
    takes lines of text from a source file, parses them as instructions and
    produces a list of output instructions in the format SHENZHEN I/O expects
    :param issues: collection of errors generated by the assembly process so far
    :param lines: a list of lines for parsing as instructions
    :param chip: information about the target microchip, for providing relevant warnings
    :return: a list of instructions ready for serialising and presenting to SHENZHEN I/O
    """

    # parse inputs
    parser = Parser(issues)
    instructions = parser.parse_lines(lines)

    # extract aliases/constants out into a dictionary
    symbol_table = symbol_pass(issues, instructions, chip)

    ir_nodes = build_ir_graph(issues, instructions)
    warn_unused_code(issues, ir_nodes)

    # this will track the resulting instruction list
    output = []

    # this will track labels that appear on their own in a line, we'll
    # delay emitting these until we see the next instruction, then we
    # will try and put this label on the same line as the next instruction
    # this is to address situations like:
    #
    #     some_label:
    #       some code here
    #
    # where this could be on one line (SHENZHEN I/O requires you to minimise lines of code!)
    # so we try to output:
    #
    #     some_label: some code here
    lonely_labels = []

    # assemble each instruction
    for inst in instructions:
        # detect labels with no instruction, emit these as late as possible (see lonely_labels above)
        if inst.label is not None and inst.mnemonic is None:
            lonely_labels.append(inst)
            continue

        # currently all virtual instructions are handled in the symbol_pass, so ignore them
        if inst.mnemonic in VIRTUAL_INSTRUCTIONS.keys():
            continue

        # perform any transformations on this instruction required
        assembled = assemble_instruction(issues, symbol_table, inst)
        if assembled is None:
            continue

        # before we add the assembled instruction, deal with any lonely labels we've acquired!
        if len(lonely_labels) > 0:
            # if we have seen lots of labels we just have to emit them on separate lines,
            # these will be put in incompressible_labels - this shouldn't happen often because
            # multiple labels to the same place are almost entirely pointless

            # if the instruction we're assembling already has a label we can't do anything,
            # so all lonely_labels are incompressible
            if assembled.label is not None:
                incompressible_labels = lonely_labels
            # the instruction has no label, so lets rebuild it with a new label!
            else:
                # only one label can win, though, the rest are incompressible
                incompressible_labels = lonely_labels[:-1]
                # compress only the most recent label
                to_compress = lonely_labels[-1]
                assembled = assembled.replace(
                    label=to_compress.label,
                )
            # output labels for those we can't compress and empty our lonely label list
            for label in incompressible_labels:
                output.append(label)
            lonely_labels = []

        # finally record the assembled/translated instruction
        output.append(assembled)

    # TODO: detect unused aliases/constants?
    # TODO: optimisation pass?

    # now we know how many lines of assembly we're generating, will it fit on the chip?
    if len(output) > chip.memory:
        issues.warning(
            SourcePosition("<whole program>", None),
            "program size exceeds chip memory ({} > {})",
            len(output),
            chip.memory
        )

    return output, ir_nodes


def assemble_instruction(issues: IssueLog, symbols: typing.Dict[str, Symbol], inst: [Instruction]):
    """
    assemble a single instruction
    :param issues: record of problems encountered during assembly
    :param symbols: the symbol table from the symbol_pass
    :param inst: the instruction to assemble
    :return: the instruction after any transformations have been applied
    """
    args = []

    # TODO: accumulate labels in here, then merge repeated labels?

    # fetch instruction details and abort if unable to find some
    info = INSTRUCTIONS.get(inst.mnemonic, None)
    if info is None:
        issues.error(
            inst.source_pos,
            "unknown instruction mneumonic: {}",
            inst.mnemonic
        )
        return None

    # replace all symbols with their value
    for given_arg, expected_type in zip_longest(inst.args, info.argtypes):
        # ensure the right number of arguments are provided
        if given_arg is None:
            issues.error(
                inst.source_pos,
                "too few arguments to {} instruction",
                inst.mnemonic
            )
            return None

        if expected_type is None:
            issues.error(
                inst.source_pos,
                "too many arguments to {} instruction",
                inst.mnemonic
            )
            return None

        # TODO: check argument types
        # TODO: check references to registers are valid on current chip

        if given_arg in symbols:
            args.append(symbols[given_arg].value)
        else:
            args.append(given_arg)

    # return a transformed instruction, where the only thing that can really change is the arguments
    result = inst.replace(
        args=args,
    )
    return result


def symbol_pass(issues: IssueLog, instructions: [Instruction], chip: ChipInfo) -> typing.Dict[str, Symbol]:
    """
    scan through the instructions looking for aliases and constant definitions, producing a table of them
    :param issues: collection of issues generated during assembler execution
    :param instructions: the instructions to scan
    :param chip: information about the target chip, in order to diagnose bad register aliases
    :return: a dictionary of symbols
    """
    result = {}

    # scan each instruction
    for inst in instructions:
        # if it isn't an alias/const then we don't care, skip it
        if inst.mnemonic not in (FAKE_OP_ALIAS, FAKE_OP_CONST):
            continue

        # check we have enough arguments
        if len(inst.args) < 2:
            issues.error(
                inst.source_pos,
                "expected two arguments to {}: name and value",
                inst.mnemonic
            )
            continue

        name = inst.args[0]
        value = inst.args[1]

        if name in result:
            issues.error(
                inst.source_pos,
                "redefinition of symbol '{}', previously declared here: {}",
                name,
                result[name].source_pos
            )
            continue

        # ensure that the name of the alias/const isn't going to collide with any register names!
        if chip.registers.get(name, None):
            issues.error(
                inst.source_pos,
                "cannot use {} as an {} name, reserved as a register name on this chip",
                name,
                inst.mnemonic
            )
            continue

        # ensure that any aliases actually refer to real registers!
        if inst.mnemonic == FAKE_OP_ALIAS and chip.registers.get(value, None) is None:
            issues.error(
                inst.source_pos,
                "{} is an invalid alias as '{}' is not a valid register name on this chip",
                name,
                value
            )
            continue

        # ensure that constants are valid
        if inst.mnemonic == FAKE_OP_CONST:
            # we currently only support integer literal constants

            # ensure it parses as an integer
            try:
                as_integer = int(value)
            except ValueError:
                issues.error(
                    inst.source_pos,
                    "constants currently only support integer literals"
                )
                continue

            # ensure it's within the range of integers that SHENZHEN I/O requires
            if not (-999 <= as_integer <= 999):
                issues.error(
                    inst.source_pos,
                    "integer constants must be between -999 and 999 inclusive"
                )
                continue

        # record the new alias/const
        log.verbose("symbol {} is {} of {}".format(
            name, inst.mnemonic, value
        ))
        result[name] = Symbol(
            source_pos=inst.source_pos,
            name=name,
            value=value
        )
    return result
